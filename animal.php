<!--Опиши 3 основных принципа ООП. 
Что такое классы, как объявляются классы в php. Что такое объект? Чем отличается класс от объекта? Создать файл animal.php объявляющий класс Animal.В данной классе объявить 2 свойства: species и type со значением null. Что такое конструктор и как он объявляется в php? Добавь в класс Animal конструктор в котором свойствам species и type присваиваются какие-нибудь значения. Создать две функции getSpecies и getType, возвращающие объявленные свойства.
В чем разница между self и $this?
Что такое статические функции. В файле animal.php добавить 2 статические функции setPeices и setType принимающие по одному параметру и устанавливающие значения свойств peices и type равными принимаемым параметрам.-->
<?php
/*ООП основанно на: инкапсуляции, полиморфизме и наследовании. Инкапсуляция (encapsulation) - это механизм, который объединяет данные и код, манипулирующий зтими данными, а также защищает и то, и другое от внешнего вмешательства или неправильного использования. Полиморфизм (polymorphism) - это свойство, которое позволяет одно и то же имя использовать для решения двух или более схожих, но технически разных задач. Наследование (inheritance) - это процесс, посредством которого один объект может приобретать свойства другого. Точнее, объект может наследовать основные свойства другого объекта и добавлять к ним черты, характерные только для него. http://www.codenet.ru/progr/cpp/ipn.php */

/*Классы - это своего рода контейнеры, которые объединяют логически связанные данные и функции. Экземпляр класса - это объект. Объект - это совокупность данных (свойств) и функций (методов) для их обработки. Свойства и методы называются членами класса. Вообще, объектом является все то, что поддерживает инкапсуляцию. Если класс можно рассматривать как тип данных, то объект — как переменную (по аналогии). Скрипт может одновременно работать с несколькими объектами одного класса, как с несколькими переменными. http://www.php.su/learnphp/phpoo/?classes https://true-coder.ru/oop-v-php/oop-v-php-klassy-ekzemplyary-klassa-polya-metody-i-konstruktory.html */

/*В PHP переменные локальны. Это значит, что переменная, определенная и получившая значение внутри функции (метода), существует только во время выполнения этой функции (метода). При выходе из метода локальная переменная уничтожается, а при повторном входе — создается заново. Ключевое слово static, написанное перед присваиванием значения локальной переменной, приводит к следующим эффектам:
- Присваивание выполняется только один раз, при первом вызове функции.
- Значение помеченной таким образом переменной сохраняется после окончания работы функции.
- При последующих вызовах функции вместо присваивания переменная получает сохраненное ранее значение.
https://habrahabr.ru/post/259627/ */

class Animal{ //Объявление класса. В нутри: описание членов класса - свойств и методов для их обработки
	var $species=null; //Объявление свойства. Переменные, которые являются членами класса, называются "свойства". Спецификатор public обеспечивает доступ к полю из любого места, protected – только из классов стоящих в той же цепочке наследования (из класса-потомка, из потомка потомка и т.д.) и private запрещает доступ ото всюду, кроме самого класса
	var $type=null;
	
	public function __construct($species, $type){ //Создание конструктора класса. __construct() - магический метод, который PHP вызывает для создания экземпляра вашего класса. Он принимает любое количество аргументов. Он вызывается при создании экземпляра класса и, как правило, выполняет действия по его инициализации
		$this->species=$species;
		$this->type=$type;
	}	
	
	static public $peices = 1; //Объявляем статистическую переменную
	static public $types = 2;

    static public function setPeices() {
        echo "<pre>" . self::$peices . " \n</pre>"; ////Обращение к $peices
    }
	
	static public function setType() {
		echo "<pre>" . self::$types . " \n</pre>";
	}
	
	public function getSpecies(){
		echo "<pre>", $this->species, " \n</pre>"; 
	}
	public function getType(){
		echo "<pre>", $this->type, " \n</pre>";
	}
}
 
$one_object=new Animal ("text_A", "text_B"); //Объявления объекта. Для этого необходимо использовать оператор new. Создаем объект класса Animal и задаём значения объявленных в классе переменных $species, $type
$two_object=new Animal ("text_C", "text_D");

$one_object->getSpecies(); //Вызываем функцию getSpecies в классе $one_object, -> - оператор вызова класса (в C++ - ".")
$one_object->getType();
$two_object->getSpecies();
$two_object->getType();
$two_object->setPeices(); //Выведем значение статистических переменных
$two_object->setType();

/*Статические функции должны использовать только статические переменные. self ТОЛЬКО для статических функций, свойств. this ТОЛЬКО для нестатических переменных. this требует, чтобы класс был проинстанцирован, self не требует. http://evilcoderr.blogspot.ru/2013/12/this-self-php.html */

//$this - это ССЫЛКА на ТЕКУЩИЙ объект и она нужна, чтобы обратиться к переменной в КОНТЕКСТЕ класса
class human_this1 {
     public $a;
     public function klassFuncA() {
		 
	 }
     function getA() {
            echo $this->a; //Правильно. echo $a; - неправильно, обратиться не к переменной public a
            
            $this->klassFunc(); //Вызов метода класса
     }
}
//Обычна нужна, чтобы инициализировать поля в конструкторе 
class human_this2 {
     public $b;   
     public function __construct($b){
          $this->b = $b; //$b = $b; - будет ошибка         
     }
}

//$self используется в том, же самом ключе, но уже для СТАТИЧЕСКИХ свойств
class human_self {
     static $c = "text";    
     function getC() {
            echo self::$c; //Обращение к c, echo $this->c; - null или ошибка. НЕЛЬЗЯ
     }
}
?>